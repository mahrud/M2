use arithmetic;
use nets; -- for dummyNetList
use M2;   -- for tostring

-----------------------------------------------------------------------------
-- Exported variables
-----------------------------------------------------------------------------

export tabWidth := 8;

export STDIN   ::= 0;
export STDOUT  ::= 1;
export STDERR  ::= 2;
export NOERROR ::= 0;
export NOFD    ::= -1;
export ERROR   ::= -1;
export EOF     ::= -2; -- end of file

export iseof(c:int):bool   := c == EOF;
export iserror(c:int):bool := c == ERROR;

-----------------------------------------------------------------------------
-- C++ interface functions defined in std-stream.cpp
-----------------------------------------------------------------------------

import Sinitialize(fd:int, live:bool):void;

-- TODO: find a way to allow C++ here, then replace this and sgetc..sputn
--declarations "#include <sstream>";
--export stringstream := Type "std::stringstream *";
export stringstream := Type "struct stringstream *";
import Sstringstream(str:string):stringstream;
export Sstringstream():stringstream := Sstringstream("");

--export stringbuf := Type "std::stringbuf *";
export stringbuf := Type "struct stringbuf *";
import Sstringbuf(stream:stringstream):stringbuf;
--export Sstringbuf(str:string):stringbuf := Sstringbuf(Sstringstream(""));

-- TODO: implement string access, like an actual string
--export (buf:stringbuf) . (i:size_t) : char := ...
--export (buf:stringbuf) . (i:size_t) : char := ...

-- TODO: get length to work on a stringstream
-- TODO: convert almost all int to size_t
import Slength(buf:stringstream):int;

import Sflush(fd:int, buf:stringstream):int;

--import Swrite(fd:int, buf:stringstream, offset:int, n:int):int;
--export Swrite(fd:int, buf:stringstream, offset:int):int := Swrite(fd, buf, offset, Slength(buf) - offset);
--export Swrite(fd:int, buf:stringstream):int := Swrite(fd, buf, 0, Slength(buf));

import Sgetc(                 buf:stringstream):int;    -- := Ccode(int, buf,"->sgetc()");
import Sgetn(s:string, n:int, buf:stringstream):int; -- := Ccode(int, buf,"->sgetn(",s,",",n,")");
import Sputc(c:char,          buf:stringstream):int;    -- := Ccode(int, buf,"->sputc(",c,")");
import Sputn(s:string, n:int, buf:stringstream):int; -- := Ccode(int, buf,"->sputn(",s,",",n,")");

import Srewindc(buf:stringstream):int;

import Stostring(buf:stringstream, offset:int, n:int):string;
export Stostring(buf:stringstream, offset:int):string := Stostring(buf, offset, Slength(buf) - offset);
export Stostring(buf:stringstream):string := Stostring(buf, 0, Slength(buf)); -- TODO: memory inefficient
--export Stostring(buf:stringstream):string := tostring(Ccode(constcharstar, buf,"->str().c_str()"));

import Sempty(buf:stringstream):void;

-----------------------------------------------------------------------------
-- Local utilities
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Exported Functions
-----------------------------------------------------------------------------

export newbuffer():string := ""; -- new string len bufsize do provide ' ';

-- FOSS, or File Output Sync State, is the thread local data needed for
-- performing synchronization functionality for a given top level file
export FOSS := {+
     	-- output file stuff
	outbuffer:stringstream,	-- buffer
	                        -- outbuffer . 0 is the first char in the buffer
	outindex:int,	        -- outbuffer.(outindex-1) is the last char
	outbol:int,	        -- outbuffer.outbol = first char of the current line
	     	       	        -- The text after this point may be combined with
				-- subsequently printed nets.
        hadNet:bool,		-- whether a Net is present, in which case the
	     	       	        -- buffer will be empty
	nets:NetList,	        -- list of nets, to be printed after the outbuffer
	outmargin:int,	        -- outbuffer.outmargin is the number of chars written on the last line
        bytesWritten:int,       -- bytes written so far
	lastCharOut:int,        -- when outbuffer empty, last character written, or -1 if none
        capturing:bool		-- whether file output is being captured (for use in generating example output) instead of being written to the file descriptor
    };

--provide a constructor for FOSS
export newFOSS(
 	outbuffer:string,	-- buffer
	                        -- outbuffer . 0 is the first char in the buffer
	outindex:int,	        -- outbuffer.(outindex-1) is the last char
	outbol:int,	        -- outbuffer.outbol = first char of the current line
	     	       	        -- The text after this point may be combined with
				-- subsequently printed nets.
        hadNet:bool,		-- whether a Net is present, in which case the
	     	       	        -- buffer will be empty
	nets:NetList,	        -- list of nets, to be printed after the outbuffer
        bytesWritten:int,       -- bytes written so far
	outmargin:int,	        -- outbuffer.outmargin is the number of chars written on the last line
	lastCharOut:int,        -- when outbuffer empty, last character written, or -1 if none
        capturing:bool		-- whether file output is being captured (for use in generating example output) instead of being written to the file descriptor
    ):FOSS := FOSS(Sstringstream(outbuffer), outindex, outbol, hadNet, nets, outmargin, bytesWritten, lastCharOut, capturing);

--provide a default 'constructor' for FOSS.
--this is used by m2file.cpp to create new sync states on the fly for new threads in thread exclusive mode
export newDefaultFOSS():FOSS := newFOSS(newbuffer(),0,0,false,dummyNetList,0,0,-1,false);

-----------------------------------------------------------------------------
-- Legacy Functions (to be deprecated)
-----------------------------------------------------------------------------

--provide a constant representation of default buffer size for a file
export bufsize ::= 4 * 1024;
--create a new buffer of size bufsize and initialize it to ' '
export newinbuffer():string := new string len bufsize do provide ' ';
